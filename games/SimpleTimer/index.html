<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Simple Timer</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.11.0/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

//Device scaling stuff
var timerSize = 640;

var windowTimerRatio = window.innerWidth / timerSize;

var numberOfTimersPerRow = Math.floor(windowTimerRatio);
var bufferPortion = windowTimerRatio - numberOfTimersPerRow;
var bufferSize = (bufferPortion * timerSize) / (numberOfTimersPerRow + 1)
var scaleFactor = 1;

//If the screen is not wide enough to fit one timer, have one timer that is scaled down
if(numberOfTimersPerRow == 0)
{
    numberOfTimersPerRow = 1;
    bufferPortion = 0;
    bufferSize = 0;
    scaleFactor = windowTimerRatio;
}

var config = {
    type: Phaser.AUTO
    ,width: window.innerWidth
    ,height: window.innerHeight
    ,scene: {
        preload: preload,
        create: create,
        update: update
    }
};

var game = new Phaser.Game(config);

var prevPointerY = 0;
var gameHidden = false;

var timer;

function preload ()
{
    this.load.image('timerBG', 'assets/timerBG.png');
    this.load.image('timerCenter', 'assets/timerCenter.png');
}

function create ()
{
    var worldCenterX = window.innerWidth / 2;
    var worldCenterY = window.innerHeight / 2;

    //Don't know why the actual centerY doesn't properly update?!?!?!?
    var currentCameraY = this.cameras.main.centerY;
    var canDrag = false;

    timer = createTimer(worldCenterX, worldCenterY, scaleFactor, 0x0ff000, this);

    //Make camera to scroll around
    var interpMethod = 'Cubic.easeOut';
    // Set up input
    this.input.on("pointerdown", function (pointer) {
        prevPointerY = pointer.y;
        canDrag = true;
    }, this);

    this.input.on("pointermove", function (pointer) {
        if(canDrag && pointer.y != prevPointerY)
        {
            let newToOldMouseY = prevPointerY - pointer.y;
            let newPos = currentCameraY + newToOldMouseY;
            this.cameras.main.pan(worldCenterX, newPos, 100, interpMethod, true);

            prevPointerY = pointer.y;
            currentCameraY = newPos;
        }
    }, this);

    this.input.on("pointerup", function (pointer) {
        canDrag = false;

        //Kinetic, baby
        if(pointer.y != prevPointerY)
        {
            let newToOldMouseY = prevPointerY - pointer.y;
            let newPos = currentCameraY + newToOldMouseY * 8;
            this.cameras.main.pan(worldCenterX, newPos, 200, interpMethod, true);

            prevPointerY = pointer.y;
            currentCameraY = newPos;
        }
    }, this);
}

function update ()
{
    let remaining = timer.getRemainingTime();

    if(timer.pauseTime > 0)
    {
        remaining = timer.duration - (timer.pauseTime - timer.startTime);
    }

    //Ceiling so that 00;00 really is 0 and not 0 + some fractional part
    let prettySeconds = Math.ceil(remaining / 1000);

    let seconds = prettySeconds % 60;
    let minutes = (prettySeconds / 60) % 60;
    let hours = (prettySeconds / (60 * 60)) % 24;

    function timeFormat(number) {
        let str;
        let length = 2;

        if(number < 10)
        {
            str = number.toString().substr(0,length - 1);
            str = "0" + str;
        }
        else
        {
            str = number.toString().substr(0,length);
        }

        return str;
    }

    let timeString = timeFormat(hours) + ':' + timeFormat(minutes) + ':' + timeFormat(seconds);
    timer.timeText.setText(timeString);

    if (minutes < 1) {
        timeString = timeString.substr(6, 2);
    }
    else if (hours < 1) {
        timeString = timeString.substr(3, 5);
    }

    let titleString = "TM - " + timeString;

    if (timer.pauseTime > 0)
    {
        titleString += " [Paused]";
    }
    else if(gameHidden)
    {
        titleString += " [Hidden]"
    }

    window.document.title = titleString;
}

function createTimer(posX, posY, scaleFactor, color, context)
{
    var timer = {
        duration: 600000
        ,startTime: 0
        ,pauseTime: 0
        ,isPaused: function () {
            return this.pauseTime > 0;
        }
        ,pauseToggle: function () {
            if(!this.isPaused())
            {
                this.pauseTime = Date.now();
            }
            else
            {
                this.startTime += (Date.now() - this.pauseTime);
                this.pauseTime = 0;
            }
        }
        ,isStarted: function () {
            return this.pauseTime > this.startTime;
        }
        ,getRemainingTime: function () {
            return Math.max(this.duration - (Date.now() - this.startTime), 0);
        }

        /*
        bg
        ,center
        ,timeText
        ,resetText
        ,editText
        */
    };
    //timer.duration = 10000;
    timer.startTime = Date.now();

    timer.bg = context.add.sprite(posX, posY, 'timerBG').setScale(scaleFactor);
    timer.bg.setTint(color);

    timer.center = context.add.sprite(posX, posY, 'timerCenter').setScale(scaleFactor).setInteractive();
    timer.center.setTint(color);
    timer.center.on('pointerdown', function (pointer) {
        timer.pauseToggle();
    });

    timer.timeText = context.add.text(posX, posY, '00:00:00', {fontFamily: 'Arial', fontSize: 32});
    timer.timeText.setPosition(timer.timeText.x - timer.timeText.width / 2, timer.timeText.y - timer.timeText.height / 2);
    timer.timeText.setTint(color);

    let timerEdgeBuffer = timer.bg.width / 30;
    let timerEdgeSafeWidth = posX + timer.bg.width / 2 - timerEdgeBuffer;
    let timerEdgeSafeHeight = posY + timer.bg.height / 2 - timerEdgeBuffer;

    timer.resetText = context.add.text(timerEdgeSafeWidth, timerEdgeSafeHeight, 'reset', {fontFamily: 'Arial', fontSize: 24}).setInteractive();
    timer.resetText.setPosition(timer.resetText.x - timer.resetText.width, timer.resetText.y - timer.resetText.height);
    timer.resetText.setTint(color);
    timer.resetText.on('pointerdown', function () {
        timer.startTime = Date.now();
        timer.pauseTime = timer.startTime;
    });

    game.events.on('hidden', function(){
        gameHidden = true;
    });
    game.events.on('visible', function() {
        gameHidden = false;
    });

    return timer;
}

</script>

</body>
</html>
